# -*- coding: utf-8 -*-
"""email_spam_classifier.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kMT3Ap3in2obXEmehNIAmXl9HXXyiY4i
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline
import string
import os

from wordcloud import WordCloud, STOPWORDS, ImageColorGenerator
from PIL import Image

from sklearn.feature_extraction.text import CountVectorizer
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import MultinomialNB
from sklearn import metrics

import nltk
nltk.download('punkt')
nltk.download('stopwords')
from nltk import word_tokenize,sent_tokenize

#import metrics libraries
from sklearn.metrics import confusion_matrix
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
from sklearn.metrics import roc_auc_score
from sklearn.metrics import accuracy_score
from sklearn.metrics import classification_report

#Streamlit
#pip install streamlit
import streamlit as st

st.write("Application is running...")

#Parent Class for Data
class data_read_write(object):
    def __init__(self):
        pass
    def __init__(self, file_link):
        self.data_frame =  pd.read_csv(file_link)
    def read_csv_file(self, file_link):
        #data_frame_read = pd.read_csv(file_link)
        #return data_frame_read
        #self.data_frame = pd.read_csv(file_link)
        return self.data_frame
    def write_to_csvfile(self, file_link):
        self.data_frame.to_csv(file_link, encoding='utf-8', index=False, header=True)
        return



#Child Class for Data_read_write
class apply_embeddding_and_model(data_read_write):
    def __init__(self):
        pass
    def apply_count_vector(self, v_data_column):
        vectorizer = CountVectorizer(min_df=2, analyzer = "word",tokenizer = None,preprocessor = None,stop_words = None)
        return vectorizer.fit_transform(v_data_column)

    def predictNB(self, modelNB, X):
        # Predicting the Test set results
        y_predict = modelNB.predict(X)
        return y_predict

    def model_assessment(self, X_test, y_test, predicted_class):

#         print(y_test)
#         print(predicted_class)

        cm = confusion_matrix(y_test, predicted_class)
        
        print(classification_report(y_test, predicted_class))
        print("test set\n")

        SPAM = 1
        print('confusion matrix')
        print(cm)

        print()
        print('accuracy: ' + str(accuracy_score(y_test,predicted_class)))
        print('precision: ' + str(precision_score(y_test,predicted_class,pos_label=SPAM)))
        print('recall: ' + str(recall_score(y_test,predicted_class,pos_label= SPAM)))
        print('f-Score: ' + str(f1_score(y_test,predicted_class,pos_label= SPAM)))
        print('AUC: ' + str(roc_auc_score(np.where(y_test== SPAM, 1,0),np.where(predicted_class== SPAM, 1,0))))

        plt.matshow(cm, cmap=plt.cm.binary, interpolation='nearest')
        plt.title('confusion matrix')
        plt.colorbar()
        plt.ylabel('expected label')
        plt.xlabel('predicted label')
        plt.show()
        
    def apply_naive_bayes(self, mails):

        #DIVIDE THE DATA INTO TRAINING AND TESTING PRIOR TO TRAINING
        X_train, X_test, y_train, y_test = train_test_split(mails['clean_text'], mails['spam'], test_size=0.3, random_state=42)

        vector_model_X_train = countVectorizer.fit_transform(X_train)
        modelNB = MultinomialNB()

        #Training model
        modelNB.fit(vector_model_X_train, y_train)

        # Predicting the Test set results
        test_vector_model = countVectorizer.transform(X_test)
        y_predict_test = modelNB.predict(test_vector_model)

        #Evaluating Model
        #self.model_assessment(X_test, y_test, y_predict_test)
        
        return modelNB
    
data_frame = data_obj = data_read_write("emails.csv")
data_obj.read_csv_file("processes_file.csv")
countVectorizer = CountVectorizer()

cv_object = apply_embeddding_and_model()

modelNB = cv_object.apply_naive_bayes(data_frame)

inputMail = st.text_area('Write email here')

vector_model = countVectorizer.transform([inputMail])
mail_label = cv_object.predictNB(modelNB, vector_model)


mailData = pd.DataFrame([inputMail])
mailData.columns = ['Mail']
mailData['Label'] = mail_label
mailData['Label'] = mailData['Label'].replace([0, 1], ['Not spam', 'Spam'])
mailData
